// This is the backend code for reading and writing

// Generated by ProtocolBuffer
// - a pure c# code generation implementation of protocol buffers
// Report bugs to: https://silentorbit.com/protobuf/

// DO NOT EDIT
// This file will be overwritten when CodeGenerator is run.
using System;
using System.IO;
using System.Text;
using System.Collections.Generic;

namespace Local
{
    internal partial class LocalFeatures
    {
        /// <summary>Helper: create a new instance to deserializing into</summary>
        internal static LocalFeatures Deserialize(Stream stream)
        {
            var instance = new LocalFeatures();
            Deserialize(stream, instance);
            return instance;
        }

        /// <summary>Helper: create a new instance to deserializing into</summary>
        internal static LocalFeatures DeserializeLengthDelimited(Stream stream)
        {
            var instance = new LocalFeatures();
            DeserializeLengthDelimited(stream, instance);
            return instance;
        }

        /// <summary>Helper: create a new instance to deserializing into</summary>
        internal static LocalFeatures DeserializeLength(Stream stream, int length)
        {
            var instance = new LocalFeatures();
            DeserializeLength(stream, length, instance);
            return instance;
        }

        /// <summary>Helper: put the buffer into a MemoryStream and create a new instance to deserializing into</summary>
        internal static LocalFeatures Deserialize(byte[] buffer)
        {
            var instance = new LocalFeatures();
            using (var ms = new MemoryStream(buffer))
                Deserialize(ms, instance);
            return instance;
        }

        /// <summary>Helper: put the buffer into a MemoryStream before deserializing</summary>
        internal static Local.LocalFeatures Deserialize(byte[] buffer, Local.LocalFeatures instance)
        {
            using (var ms = new MemoryStream(buffer))
                Deserialize(ms, instance);
            return instance;
        }

        /// <summary>Takes the remaining content of the stream and deserialze it into the instance.</summary>
        internal static Local.LocalFeatures Deserialize(Stream stream, Local.LocalFeatures instance)
        {
            var br = new BinaryReader(stream);
            instance.MyEnum = LocalFeatureTest.TopEnum.First;
            while (true)
            {
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    break;
                // Optimized reading of known fields with field ID < 16
                switch (keyByte)
                {
                    // Field 1 Varint
                    case 8:
                        instance.Uptime = new TimeSpan((long)(long)global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt64(stream));
                        continue;
                    // Field 2 Varint
                    case 16:
                        instance.DueDate = new DateTime((long)(long)global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt64(stream), DateTimeKind.Utc);
                        continue;
                    // Field 3 Fixed64
                    case 25:
                        instance.Amount = br.ReadDouble();
                        continue;
                    // Field 4 LengthDelimited
                    case 34:
                        instance.Denial = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadString(stream);
                        continue;
                    // Field 5 LengthDelimited
                    case 42:
                        instance.Secret = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadString(stream);
                        continue;
                    // Field 6 LengthDelimited
                    case 50:
                        instance.Internal = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadString(stream);
                        continue;
                    // Field 7 LengthDelimited
                    case 58:
                        instance.PR = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadString(stream);
                        continue;
                    // Field 8 LengthDelimited
                    case 66:
                        Mine.MyMessageV1.DeserializeLengthDelimited(stream, instance.TestingReadOnly);
                        continue;
                    // Field 9 LengthDelimited
                    case 74:
                        if (instance.MyInterface == null)
                            throw new InvalidOperationException("Can't deserialize into a interfaces null pointer");
                        else
                            LocalFeatureTest.InterfaceTestSerializer.DeserializeLengthDelimited(stream, instance.MyInterface);
                        continue;
                    // Field 10 LengthDelimited
                    case 82:
                        LocalFeatureTest.StructTest.DeserializeLengthDelimited(stream, ref instance.MyStruct);
                        continue;
                    // Field 11 LengthDelimited
                    case 90:
                        TestB.ExternalStructSerializer.DeserializeLengthDelimited(stream, ref instance.MyExtStruct);
                        continue;
                    // Field 12 LengthDelimited
                    case 98:
                        if (instance.MyExtClass == null)
                            instance.MyExtClass = TestB.ExternalClassSerializer.DeserializeLengthDelimited(stream);
                        else
                            TestB.ExternalClassSerializer.DeserializeLengthDelimited(stream, instance.MyExtClass);
                        continue;
                    // Field 13 Varint
                    case 104:
                        instance.MyEnum = (LocalFeatureTest.TopEnum)global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt64(stream);
                        continue;
                }

                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            instance.AfterDeserialize();
            return instance;
        }

        /// <summary>Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.</summary>
        internal static Local.LocalFeatures DeserializeLengthDelimited(Stream stream, Local.LocalFeatures instance)
        {
            var br = new BinaryReader(stream);
            instance.MyEnum = LocalFeatureTest.TopEnum.First;
            long limit = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt32(stream);
            limit += stream.Position;
            while (true)
            {
                if (stream.Position >= limit)
                {
                    if (stream.Position == limit)
                        break;
                    else
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Read past max limit");
                }
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    throw new System.IO.EndOfStreamException();
                // Optimized reading of known fields with field ID < 16
                switch (keyByte)
                {
                    // Field 1 Varint
                    case 8:
                        instance.Uptime = new TimeSpan((long)(long)global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt64(stream));
                        continue;
                    // Field 2 Varint
                    case 16:
                        instance.DueDate = new DateTime((long)(long)global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt64(stream), DateTimeKind.Utc);
                        continue;
                    // Field 3 Fixed64
                    case 25:
                        instance.Amount = br.ReadDouble();
                        continue;
                    // Field 4 LengthDelimited
                    case 34:
                        instance.Denial = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadString(stream);
                        continue;
                    // Field 5 LengthDelimited
                    case 42:
                        instance.Secret = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadString(stream);
                        continue;
                    // Field 6 LengthDelimited
                    case 50:
                        instance.Internal = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadString(stream);
                        continue;
                    // Field 7 LengthDelimited
                    case 58:
                        instance.PR = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadString(stream);
                        continue;
                    // Field 8 LengthDelimited
                    case 66:
                        Mine.MyMessageV1.DeserializeLengthDelimited(stream, instance.TestingReadOnly);
                        continue;
                    // Field 9 LengthDelimited
                    case 74:
                        if (instance.MyInterface == null)
                            throw new InvalidOperationException("Can't deserialize into a interfaces null pointer");
                        else
                            LocalFeatureTest.InterfaceTestSerializer.DeserializeLengthDelimited(stream, instance.MyInterface);
                        continue;
                    // Field 10 LengthDelimited
                    case 82:
                        LocalFeatureTest.StructTest.DeserializeLengthDelimited(stream, ref instance.MyStruct);
                        continue;
                    // Field 11 LengthDelimited
                    case 90:
                        TestB.ExternalStructSerializer.DeserializeLengthDelimited(stream, ref instance.MyExtStruct);
                        continue;
                    // Field 12 LengthDelimited
                    case 98:
                        if (instance.MyExtClass == null)
                            instance.MyExtClass = TestB.ExternalClassSerializer.DeserializeLengthDelimited(stream);
                        else
                            TestB.ExternalClassSerializer.DeserializeLengthDelimited(stream, instance.MyExtClass);
                        continue;
                    // Field 13 Varint
                    case 104:
                        instance.MyEnum = (LocalFeatureTest.TopEnum)global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt64(stream);
                        continue;
                }

                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            instance.AfterDeserialize();
            return instance;
        }

        /// <summary>Read the given number of bytes from the stream and deserialze it into the instance.</summary>
        internal static Local.LocalFeatures DeserializeLength(Stream stream, int length, Local.LocalFeatures instance)
        {
            var br = new BinaryReader(stream);
            instance.MyEnum = LocalFeatureTest.TopEnum.First;
            long limit = stream.Position + length;
            while (true)
            {
                if (stream.Position >= limit)
                {
                    if (stream.Position == limit)
                        break;
                    else
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Read past max limit");
                }
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    throw new System.IO.EndOfStreamException();
                // Optimized reading of known fields with field ID < 16
                switch (keyByte)
                {
                    // Field 1 Varint
                    case 8:
                        instance.Uptime = new TimeSpan((long)(long)global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt64(stream));
                        continue;
                    // Field 2 Varint
                    case 16:
                        instance.DueDate = new DateTime((long)(long)global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt64(stream), DateTimeKind.Utc);
                        continue;
                    // Field 3 Fixed64
                    case 25:
                        instance.Amount = br.ReadDouble();
                        continue;
                    // Field 4 LengthDelimited
                    case 34:
                        instance.Denial = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadString(stream);
                        continue;
                    // Field 5 LengthDelimited
                    case 42:
                        instance.Secret = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadString(stream);
                        continue;
                    // Field 6 LengthDelimited
                    case 50:
                        instance.Internal = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadString(stream);
                        continue;
                    // Field 7 LengthDelimited
                    case 58:
                        instance.PR = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadString(stream);
                        continue;
                    // Field 8 LengthDelimited
                    case 66:
                        Mine.MyMessageV1.DeserializeLengthDelimited(stream, instance.TestingReadOnly);
                        continue;
                    // Field 9 LengthDelimited
                    case 74:
                        if (instance.MyInterface == null)
                            throw new InvalidOperationException("Can't deserialize into a interfaces null pointer");
                        else
                            LocalFeatureTest.InterfaceTestSerializer.DeserializeLengthDelimited(stream, instance.MyInterface);
                        continue;
                    // Field 10 LengthDelimited
                    case 82:
                        LocalFeatureTest.StructTest.DeserializeLengthDelimited(stream, ref instance.MyStruct);
                        continue;
                    // Field 11 LengthDelimited
                    case 90:
                        TestB.ExternalStructSerializer.DeserializeLengthDelimited(stream, ref instance.MyExtStruct);
                        continue;
                    // Field 12 LengthDelimited
                    case 98:
                        if (instance.MyExtClass == null)
                            instance.MyExtClass = TestB.ExternalClassSerializer.DeserializeLengthDelimited(stream);
                        else
                            TestB.ExternalClassSerializer.DeserializeLengthDelimited(stream, instance.MyExtClass);
                        continue;
                    // Field 13 Varint
                    case 104:
                        instance.MyEnum = (LocalFeatureTest.TopEnum)global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt64(stream);
                        continue;
                }

                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            instance.AfterDeserialize();
            return instance;
        }

        /// <summary>Serialize the instance into the stream</summary>
        internal static void Serialize(Stream stream, LocalFeatures instance)
        {
            instance.BeforeSerialize();

            var bw = new BinaryWriter(stream);
            var msField = global::SilentOrbit.ProtocolBuffers.ProtocolParser.Stack.Pop();
            // Key for field: 1, Varint
            stream.WriteByte(8);
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt64(stream,(ulong)instance.Uptime.Ticks);
            // Key for field: 2, Varint
            stream.WriteByte(16);
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt64(stream,(ulong)(instance.DueDate.Kind == DateTimeKind.Utc ? instance.DueDate : instance.DueDate.ToUniversalTime()).Ticks);
            // Key for field: 3, Fixed64
            stream.WriteByte(25);
            bw.Write(instance.Amount);
            if (instance.Denial != null)
            {
                // Key for field: 4, LengthDelimited
                stream.WriteByte(34);
                global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteBytes(stream, Encoding.UTF8.GetBytes(instance.Denial));
            }
            if (instance.Secret != null)
            {
                // Key for field: 5, LengthDelimited
                stream.WriteByte(42);
                global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteBytes(stream, Encoding.UTF8.GetBytes(instance.Secret));
            }
            if (instance.Internal != null)
            {
                // Key for field: 6, LengthDelimited
                stream.WriteByte(50);
                global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteBytes(stream, Encoding.UTF8.GetBytes(instance.Internal));
            }
            if (instance.PR != null)
            {
                // Key for field: 7, LengthDelimited
                stream.WriteByte(58);
                global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteBytes(stream, Encoding.UTF8.GetBytes(instance.PR));
            }
            if (instance.TestingReadOnly != null)
            {
                // Key for field: 8, LengthDelimited
                stream.WriteByte(66);
                ﻿msField.SetLength(0);
                Mine.MyMessageV1.Serialize(msField, instance.TestingReadOnly);
                // Length delimited byte array
                uint length8 = (uint)msField.Length;
                global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt32(stream, length8);
                msField.WriteTo(stream);

            }
            if (instance.MyInterface == null)
                throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("MyInterface is required by the proto specification.");
            // Key for field: 9, LengthDelimited
            stream.WriteByte(74);
            ﻿msField.SetLength(0);
            LocalFeatureTest.InterfaceTestSerializer.Serialize(msField, instance.MyInterface);
            // Length delimited byte array
            uint length9 = (uint)msField.Length;
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt32(stream, length9);
            msField.WriteTo(stream);

            // Key for field: 10, LengthDelimited
            stream.WriteByte(82);
            ﻿msField.SetLength(0);
            LocalFeatureTest.StructTest.Serialize(msField, instance.MyStruct);
            // Length delimited byte array
            uint length10 = (uint)msField.Length;
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt32(stream, length10);
            msField.WriteTo(stream);

            // Key for field: 11, LengthDelimited
            stream.WriteByte(90);
            ﻿msField.SetLength(0);
            TestB.ExternalStructSerializer.Serialize(msField, instance.MyExtStruct);
            // Length delimited byte array
            uint length11 = (uint)msField.Length;
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt32(stream, length11);
            msField.WriteTo(stream);

            if (instance.MyExtClass != null)
            {
                // Key for field: 12, LengthDelimited
                stream.WriteByte(98);
                ﻿msField.SetLength(0);
                TestB.ExternalClassSerializer.Serialize(msField, instance.MyExtClass);
                // Length delimited byte array
                uint length12 = (uint)msField.Length;
                global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt32(stream, length12);
                msField.WriteTo(stream);

            }
            // Key for field: 13, Varint
            stream.WriteByte(104);
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt64(stream,(ulong)instance.MyEnum);
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.Stack.Push(msField);
        }

        /// <summary>Helper: Serialize into a MemoryStream and return its byte array</summary>
        internal static byte[] SerializeToBytes(LocalFeatures instance)
        {
            using (var ms = new MemoryStream())
            {
                Serialize(ms, instance);
                return ms.ToArray();
            }
        }
        /// <summary>Helper: Serialize with a varint length prefix</summary>
        internal static void SerializeLengthDelimited(Stream stream, LocalFeatures instance)
        {
            var data = SerializeToBytes(instance);
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt32(stream, (uint)data.Length);
            stream.Write(data, 0, data.Length);
        }
    }

}
namespace LocalFeatureTest
{
    public static class InterfaceTestSerializer
    {
        /// <summary>Helper: put the buffer into a MemoryStream before deserializing</summary>
        public static LocalFeatureTest.InterfaceTest Deserialize(byte[] buffer, LocalFeatureTest.InterfaceTest instance)
        {
            using (var ms = new MemoryStream(buffer))
                Deserialize(ms, instance);
            return instance;
        }

        /// <summary>Takes the remaining content of the stream and deserialze it into the instance.</summary>
        public static LocalFeatureTest.InterfaceTest Deserialize(Stream stream, LocalFeatureTest.InterfaceTest instance)
        {
            while (true)
            {
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    break;
                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

        /// <summary>Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.</summary>
        public static LocalFeatureTest.InterfaceTest DeserializeLengthDelimited(Stream stream, LocalFeatureTest.InterfaceTest instance)
        {
            long limit = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt32(stream);
            limit += stream.Position;
            while (true)
            {
                if (stream.Position >= limit)
                {
                    if (stream.Position == limit)
                        break;
                    else
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Read past max limit");
                }
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    throw new System.IO.EndOfStreamException();
                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

        /// <summary>Read the given number of bytes from the stream and deserialze it into the instance.</summary>
        public static LocalFeatureTest.InterfaceTest DeserializeLength(Stream stream, int length, LocalFeatureTest.InterfaceTest instance)
        {
            long limit = stream.Position + length;
            while (true)
            {
                if (stream.Position >= limit)
                {
                    if (stream.Position == limit)
                        break;
                    else
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Read past max limit");
                }
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    throw new System.IO.EndOfStreamException();
                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

        /// <summary>Serialize the instance into the stream</summary>
        public static void Serialize(Stream stream, InterfaceTest instance)
        {
            var msField = global::SilentOrbit.ProtocolBuffers.ProtocolParser.Stack.Pop();
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.Stack.Push(msField);
        }

        /// <summary>Helper: Serialize into a MemoryStream and return its byte array</summary>
        public static byte[] SerializeToBytes(InterfaceTest instance)
        {
            using (var ms = new MemoryStream())
            {
                Serialize(ms, instance);
                return ms.ToArray();
            }
        }
        /// <summary>Helper: Serialize with a varint length prefix</summary>
        public static void SerializeLengthDelimited(Stream stream, InterfaceTest instance)
        {
            var data = SerializeToBytes(instance);
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt32(stream, (uint)data.Length);
            stream.Write(data, 0, data.Length);
        }
    }

    public partial struct StructTest
    {
        /// <summary>Helper: create a new instance to deserializing into</summary>
        public static StructTest Deserialize(Stream stream)
        {
            var instance = new StructTest();
            Deserialize(stream, ref instance);
            return instance;
        }

        /// <summary>Helper: create a new instance to deserializing into</summary>
        public static StructTest DeserializeLengthDelimited(Stream stream)
        {
            var instance = new StructTest();
            DeserializeLengthDelimited(stream, ref instance);
            return instance;
        }

        /// <summary>Helper: create a new instance to deserializing into</summary>
        public static StructTest DeserializeLength(Stream stream, int length)
        {
            var instance = new StructTest();
            DeserializeLength(stream, length, ref instance);
            return instance;
        }

        /// <summary>Helper: put the buffer into a MemoryStream and create a new instance to deserializing into</summary>
        public static StructTest Deserialize(byte[] buffer)
        {
            var instance = new StructTest();
            using (var ms = new MemoryStream(buffer))
                Deserialize(ms, ref instance);
            return instance;
        }

        /// <summary>Helper: put the buffer into a MemoryStream before deserializing</summary>
        public static LocalFeatureTest.StructTest Deserialize(byte[] buffer, ref LocalFeatureTest.StructTest instance)
        {
            using (var ms = new MemoryStream(buffer))
                Deserialize(ms, ref instance);
            return instance;
        }

        /// <summary>Takes the remaining content of the stream and deserialze it into the instance.</summary>
        public static LocalFeatureTest.StructTest Deserialize(Stream stream, ref LocalFeatureTest.StructTest instance)
        {
            while (true)
            {
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    break;
                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

        /// <summary>Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.</summary>
        public static LocalFeatureTest.StructTest DeserializeLengthDelimited(Stream stream, ref LocalFeatureTest.StructTest instance)
        {
            long limit = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt32(stream);
            limit += stream.Position;
            while (true)
            {
                if (stream.Position >= limit)
                {
                    if (stream.Position == limit)
                        break;
                    else
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Read past max limit");
                }
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    throw new System.IO.EndOfStreamException();
                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

        /// <summary>Read the given number of bytes from the stream and deserialze it into the instance.</summary>
        public static LocalFeatureTest.StructTest DeserializeLength(Stream stream, int length, ref LocalFeatureTest.StructTest instance)
        {
            long limit = stream.Position + length;
            while (true)
            {
                if (stream.Position >= limit)
                {
                    if (stream.Position == limit)
                        break;
                    else
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Read past max limit");
                }
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    throw new System.IO.EndOfStreamException();
                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

        /// <summary>Serialize the instance into the stream</summary>
        public static void Serialize(Stream stream, StructTest instance)
        {
            var msField = global::SilentOrbit.ProtocolBuffers.ProtocolParser.Stack.Pop();
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.Stack.Push(msField);
        }

        /// <summary>Helper: Serialize into a MemoryStream and return its byte array</summary>
        public static byte[] SerializeToBytes(StructTest instance)
        {
            using (var ms = new MemoryStream())
            {
                Serialize(ms, instance);
                return ms.ToArray();
            }
        }
        /// <summary>Helper: Serialize with a varint length prefix</summary>
        public static void SerializeLengthDelimited(Stream stream, StructTest instance)
        {
            var data = SerializeToBytes(instance);
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt32(stream, (uint)data.Length);
            stream.Write(data, 0, data.Length);
        }
    }

}
namespace TestB
{
    public static class ExternalStructSerializer
    {
        /// <summary>Helper: create a new instance to deserializing into</summary>
        public static ExternalStruct Deserialize(Stream stream)
        {
            var instance = new ExternalStruct();
            Deserialize(stream, ref instance);
            return instance;
        }

        /// <summary>Helper: create a new instance to deserializing into</summary>
        public static ExternalStruct DeserializeLengthDelimited(Stream stream)
        {
            var instance = new ExternalStruct();
            DeserializeLengthDelimited(stream, ref instance);
            return instance;
        }

        /// <summary>Helper: create a new instance to deserializing into</summary>
        public static ExternalStruct DeserializeLength(Stream stream, int length)
        {
            var instance = new ExternalStruct();
            DeserializeLength(stream, length, ref instance);
            return instance;
        }

        /// <summary>Helper: put the buffer into a MemoryStream and create a new instance to deserializing into</summary>
        public static ExternalStruct Deserialize(byte[] buffer)
        {
            var instance = new ExternalStruct();
            using (var ms = new MemoryStream(buffer))
                Deserialize(ms, ref instance);
            return instance;
        }

        /// <summary>Helper: put the buffer into a MemoryStream before deserializing</summary>
        public static TestB.ExternalStruct Deserialize(byte[] buffer, ref TestB.ExternalStruct instance)
        {
            using (var ms = new MemoryStream(buffer))
                Deserialize(ms, ref instance);
            return instance;
        }

        /// <summary>Takes the remaining content of the stream and deserialze it into the instance.</summary>
        public static TestB.ExternalStruct Deserialize(Stream stream, ref TestB.ExternalStruct instance)
        {
            var br = new BinaryReader(stream);
            while (true)
            {
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    break;
                // Optimized reading of known fields with field ID < 16
                switch (keyByte)
                {
                    // Field 1 Fixed64
                    case 9:
                        instance.X = br.ReadDouble();
                        continue;
                }

                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

        /// <summary>Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.</summary>
        public static TestB.ExternalStruct DeserializeLengthDelimited(Stream stream, ref TestB.ExternalStruct instance)
        {
            var br = new BinaryReader(stream);
            long limit = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt32(stream);
            limit += stream.Position;
            while (true)
            {
                if (stream.Position >= limit)
                {
                    if (stream.Position == limit)
                        break;
                    else
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Read past max limit");
                }
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    throw new System.IO.EndOfStreamException();
                // Optimized reading of known fields with field ID < 16
                switch (keyByte)
                {
                    // Field 1 Fixed64
                    case 9:
                        instance.X = br.ReadDouble();
                        continue;
                }

                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

        /// <summary>Read the given number of bytes from the stream and deserialze it into the instance.</summary>
        public static TestB.ExternalStruct DeserializeLength(Stream stream, int length, ref TestB.ExternalStruct instance)
        {
            var br = new BinaryReader(stream);
            long limit = stream.Position + length;
            while (true)
            {
                if (stream.Position >= limit)
                {
                    if (stream.Position == limit)
                        break;
                    else
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Read past max limit");
                }
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    throw new System.IO.EndOfStreamException();
                // Optimized reading of known fields with field ID < 16
                switch (keyByte)
                {
                    // Field 1 Fixed64
                    case 9:
                        instance.X = br.ReadDouble();
                        continue;
                }

                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

        /// <summary>Serialize the instance into the stream</summary>
        public static void Serialize(Stream stream, ExternalStruct instance)
        {
            var bw = new BinaryWriter(stream);
            var msField = global::SilentOrbit.ProtocolBuffers.ProtocolParser.Stack.Pop();
            // Key for field: 1, Fixed64
            stream.WriteByte(9);
            bw.Write(instance.X);
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.Stack.Push(msField);
        }

        /// <summary>Helper: Serialize into a MemoryStream and return its byte array</summary>
        public static byte[] SerializeToBytes(ExternalStruct instance)
        {
            using (var ms = new MemoryStream())
            {
                Serialize(ms, instance);
                return ms.ToArray();
            }
        }
        /// <summary>Helper: Serialize with a varint length prefix</summary>
        public static void SerializeLengthDelimited(Stream stream, ExternalStruct instance)
        {
            var data = SerializeToBytes(instance);
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt32(stream, (uint)data.Length);
            stream.Write(data, 0, data.Length);
        }
    }

    public static class ExternalClassSerializer
    {
        /// <summary>Helper: create a new instance to deserializing into</summary>
        public static ExternalClass Deserialize(Stream stream)
        {
            var instance = new ExternalClass();
            Deserialize(stream, instance);
            return instance;
        }

        /// <summary>Helper: create a new instance to deserializing into</summary>
        public static ExternalClass DeserializeLengthDelimited(Stream stream)
        {
            var instance = new ExternalClass();
            DeserializeLengthDelimited(stream, instance);
            return instance;
        }

        /// <summary>Helper: create a new instance to deserializing into</summary>
        public static ExternalClass DeserializeLength(Stream stream, int length)
        {
            var instance = new ExternalClass();
            DeserializeLength(stream, length, instance);
            return instance;
        }

        /// <summary>Helper: put the buffer into a MemoryStream and create a new instance to deserializing into</summary>
        public static ExternalClass Deserialize(byte[] buffer)
        {
            var instance = new ExternalClass();
            using (var ms = new MemoryStream(buffer))
                Deserialize(ms, instance);
            return instance;
        }

        /// <summary>Helper: put the buffer into a MemoryStream before deserializing</summary>
        public static TestB.ExternalClass Deserialize(byte[] buffer, TestB.ExternalClass instance)
        {
            using (var ms = new MemoryStream(buffer))
                Deserialize(ms, instance);
            return instance;
        }

        /// <summary>Takes the remaining content of the stream and deserialze it into the instance.</summary>
        public static TestB.ExternalClass Deserialize(Stream stream, TestB.ExternalClass instance)
        {
            while (true)
            {
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    break;
                // Optimized reading of known fields with field ID < 16
                switch (keyByte)
                {
                    // Field 1 Varint
                    case 8:
                        instance.A = (int)global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt64(stream);
                        continue;
                }

                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

        /// <summary>Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.</summary>
        public static TestB.ExternalClass DeserializeLengthDelimited(Stream stream, TestB.ExternalClass instance)
        {
            long limit = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt32(stream);
            limit += stream.Position;
            while (true)
            {
                if (stream.Position >= limit)
                {
                    if (stream.Position == limit)
                        break;
                    else
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Read past max limit");
                }
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    throw new System.IO.EndOfStreamException();
                // Optimized reading of known fields with field ID < 16
                switch (keyByte)
                {
                    // Field 1 Varint
                    case 8:
                        instance.A = (int)global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt64(stream);
                        continue;
                }

                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

        /// <summary>Read the given number of bytes from the stream and deserialze it into the instance.</summary>
        public static TestB.ExternalClass DeserializeLength(Stream stream, int length, TestB.ExternalClass instance)
        {
            long limit = stream.Position + length;
            while (true)
            {
                if (stream.Position >= limit)
                {
                    if (stream.Position == limit)
                        break;
                    else
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Read past max limit");
                }
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    throw new System.IO.EndOfStreamException();
                // Optimized reading of known fields with field ID < 16
                switch (keyByte)
                {
                    // Field 1 Varint
                    case 8:
                        instance.A = (int)global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadUInt64(stream);
                        continue;
                }

                var key = global::SilentOrbit.ProtocolBuffers.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::SilentOrbit.ProtocolBuffers.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::SilentOrbit.ProtocolBuffers.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

        /// <summary>Serialize the instance into the stream</summary>
        public static void Serialize(Stream stream, ExternalClass instance)
        {
            var msField = global::SilentOrbit.ProtocolBuffers.ProtocolParser.Stack.Pop();
            // Key for field: 1, Varint
            stream.WriteByte(8);
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt64(stream,(ulong)instance.A);
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.Stack.Push(msField);
        }

        /// <summary>Helper: Serialize into a MemoryStream and return its byte array</summary>
        public static byte[] SerializeToBytes(ExternalClass instance)
        {
            using (var ms = new MemoryStream())
            {
                Serialize(ms, instance);
                return ms.ToArray();
            }
        }
        /// <summary>Helper: Serialize with a varint length prefix</summary>
        public static void SerializeLengthDelimited(Stream stream, ExternalClass instance)
        {
            var data = SerializeToBytes(instance);
            global::SilentOrbit.ProtocolBuffers.ProtocolParser.WriteUInt32(stream, (uint)data.Length);
            stream.Write(data, 0, data.Length);
        }
    }

}
namespace Mine
{
}
namespace Yours
{
}
namespace Theirs
{
}
namespace Proto.Test
{
}
